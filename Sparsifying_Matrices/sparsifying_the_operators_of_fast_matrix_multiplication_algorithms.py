# -*- coding: utf-8 -*-
"""Sparsifying the Operators of Fast Matrix Multiplication Algorithms

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cb-BHZT9A5hm9nFGi-zcGApBnk25LKgp
"""

from itertools import combinations
from numpy.linalg import matrix_rank
import numpy as np
from sympy import *
import math
from fractions import Fraction

def gaussian_elimination(A, U):
    m, n = A.shape
    # Create the augmented matrix by concatenating A and U
    augmented_matrix = np.hstack((A, U.reshape(-1, 1)))
    for j in range(n):
        # Find the pivot row
        pivot_row = None
        for k in range(j, m):
            if augmented_matrix[k, j] != 0:
                pivot_row = k
                break

        if pivot_row is None:
            # No pivot in this column, skip to the next column
            continue

        # Swap current row with pivot row if needed
        if pivot_row != j:
            augmented_matrix[[j, pivot_row]] = augmented_matrix[[pivot_row, j]]

        # Normalize the pivot row
        augmented_matrix[j] = augmented_matrix[j] / augmented_matrix[j, j]

        # Eliminate the current column in all other rows
        for i in range(m):
            if i != j:
                augmented_matrix[i] -= augmented_matrix[i, j] * augmented_matrix[j]

    # Check for inconsistency
    for i in range(n, m):
        if augmented_matrix[i, -1] != 0:
            return None  # No solution

    return augmented_matrix[:n, -1]

# Example usage:
'''A = np.array([[2, 1], [1, 3], [0, 4]])
U = np.array([1, 2, 3])
result = gaussian_elimination(A, U)
print("Solution:", result)'''

# Example usage
'''A = np.array([[4, 7,5], [2, 6,7],[1,2,3]])
gaussian_integer_elimination(A)'''

#same notations as in the article, except for lamda it's t
def Cnk(x,y):
  return list(combinations(y, x))

def matrix_u(x, s):
    return x[:, s]

def inverse(x):
  return np.linalg.inv(x)

def supp(x):
  return [i for i in range(len(x)) if x[i]!=0]

def nnz(matrix):
  return np.count_nonzero(np.array([[Fraction(value).limit_denominator() for value in row] for row in matrix]))

def algorithm2_3(u):
  global omega
  global preprocessed
  omega,preprocessed=[],[j for j in Cnk(len(u)-1,[i for i in range(len(u[0]))]) if matrix_rank(matrix_u(u,list(j)))== len(u)-1]
  for j in range(len(u)):
    v,i=algorithm3(u)
    if(i is not None):
      u[i]=v
      omega+=[i]
  return u

def algorithm2_4(u):
  global omega
  omega=[]
  for j in range(len(u)):
    v,i=algorithm4(u)
    if(i is not None):
      u[i]=v
      omega+=[i]
  return u

def algorithm3(u):
  sparsity,sparsest,i=0,None,None
  for c in preprocessed:
    Uc=matrix_u(u,list(c))
    if(omega_validator3(Uc) is not None):
      t=omega_validator3(Uc)
      v=t.dot(u)
      E=[i for i in v if i==0]
      if len(E) > sparsity:
        sparsity,sparsest=len(E),v
        i=[i for i in supp(t) if i not in omega][0]
  return sparsest,i

def algorithm4(u):
  n,m=u.shape
  a=[i for i in range(m-1,n-2,-1)]
  for z in a:
    for c in Cnk(z,[i for i in range(m)]):
      Uc=matrix_u(u,list(c))
      if(omega_validator4(Uc) is not None):
        t=omega_validator4(Uc)
        v=t.dot(u)
        i=[i for i in supp(t) if i not in omega][0]
        return v,i

def algorithm5(u):
  m,n=u.shape
  sparsity,basis=nnz(u),np.eye(n)
  for c in Cnk(m,[i for i in range(n)]):
    Uc=matrix_u(u, list(c))
    if(matrix_rank(Uc)== m):
      sparsifier=inverse(Uc)
      if nnz(sparsifier.dot(u))<sparsity:
        sparsity,basis=nnz(sparsifier.dot(u)),sparsifier
  return basis

def omega_validator3(u):
  a=[i for i in range(len(u)) if i not in omega]
  for i in a:
    u_without_ith_row = np.delete(u, i, axis=0)
    if(matrix_rank(u_without_ith_row)==len(u)-1):
      '''because that matrix rank is n-1, square and dimension n-1 it's invertible so we compute the inverse using numpy and we have chosen ith component of lamda equal to -1 for simplicity
      but we can use the gaussian_integer_elimination and choose ith component of lamda equal to the product of the diagnol matrix to get a lambda full of integers'''
      result=u[i]@(inverse(u_without_ith_row))
      return np.insert(result, i, -1)

def omega_validator4(u):
  a=[i for i in range(len(u)) if i not in omega]
  for i in a:
    u_without_ith_row = np.delete(u, i, axis=0)
    if(matrix_rank(u_without_ith_row)==len(u)-1):
      result=gaussian_elimination(u_without_ith_row.T,u[i])
      if(result is not None):
        return np.insert(result, i, -1)

'''example0=np.array([[ 4/9 , -8/9  ,-8/9 , -4/9],
 [ 0 , 5/9 , 0,  10/9],
 [ 8/9  ,-2/3 , 0  ,0],
 [ 4/9  ,2/9 , 8/9,  4/9],
 [ 0 , -10/9 , 0 , 0],
 [ 4/9 , -1/3,  -8/9  ,2/3],
 [ -4/9 , -2/9,  8/9  ,4/9]])

example1=np.array([[ 4/9 , -8/9  ,-8/9 , -4/9],
 [ 0 , 5/9 , 0,  10/9],
 [ 8/9  ,-2/3 , 0  ,0],
 [ 4/9  ,2/9 , 8/9,  4/9],
 [ 0 , -10/9 , 0 , 0],
 [ 4/9 , -1/3,  -8/9  ,2/3],
 [ -4/9 , -2/9,  8/9  ,4/9]])
example2=np.array([[ 4/9 , -8/9  ,-8/9 , -4/9],
 [ 0 , 5/9 , 0,  10/9],
 [ 8/9  ,-2/3 , 0  ,0],
 [ 4/9  ,2/9 , 8/9,  4/9],
 [ 0 , -10/9 , 0 , 0],
 [ 4/9 , -1/3,  -8/9  ,2/3],
 [ -4/9 , -2/9,  8/9  ,4/9]])

b = np.array([[8/9, -2/3, 0, 0],
              [0, 5/9, 0, 10/9],
              [0, -10/9, 0, 0],
              [4/9, -8/9, -8/9, -4/9]])

c = np.array([[0, 0, 0, 1],
              [0, 1, 0, 0],
              [1, 0, 0, 0],
              [1, 0, 0, -1],
              [0, 0, 1, 0],
              [0, 1, 0, 1],
              [0, 0, 1, -1]])

result = c.dot(b)#example=result
print(result.T)'''

'''print("Exact Solutions")
print(algorithm2_3(example0.T),nnz(algorithm2_3(example0.T)))
print(algorithm2_4(example1.T))
print("heuristic Solutions")
print(nnz(algorithm5(example2.T)@example2.T))'''

'''matrix_fraction = np.array([[Fraction(value).limit_denominator() for value in row] for row in algorithm2_3(example0.T)])
np.count_nonzero(matrix_fraction)'''


def input_sparse_matrix():
    # Read the first triple: number of rows, number of columns, and type
    rows, cols, matrix_type = input("Enter the number of rows, number of columns, and matrix type (M/R/etc.): ").split()
    rows = int(rows)
    cols = int(cols)
    if matrix_type == 'M':
      matrix = np.zeros((rows, cols), dtype=int)
    elif matrix_type == 'R':
      matrix = np.zeros((rows, cols), dtype=object)
    # Initialize the list for storing non-zero entries
    sparse_matrix = [(rows, cols, matrix_type)]

    print("Enter the non-zero entries in the format: row-index col-index value")
    print("Enter '0 0 0' to end input")

    while True:
        entry = input()
        r, c, v = entry.split()
        r = int(r)
        c = int(c)
        if r==0 and c==0 and v=='0':
            break
        sparse_matrix.append((r, c, v))
        if matrix_type == 'M':
            matrix[r-1][c-1] = int(v)  # Adjusting for 0-based indexing
        elif matrix_type == 'R':
          matrix[r-1][c-1] = Fraction(v)  # Adjusting for 0-based indexing

    return matrix, sparse_matrix

def input_matrix():
    rows = []
    print("Enter the matrix. Use '&' to separate rows. Type 'end' to finish input:")
    while True:
        row_input = input()
        if row_input.strip().lower() == 'end':
            break
        row = [Fraction(frac_str.strip()) for frac_str in row_input.split('&')]
        rows.append(row)
    return np.array(rows, dtype=object)

def print_matrix(matrix):
    for row in matrix:
        print(" ".join(map(str, row)))
def print_sms(sparse):
  for i in sparse:
    print(i[0],i[1],i[2])
  print("0 0 0")

def main():
  y=input("Enter C for classical way(Row by row) of entering a matrix or S for the SMS format")
  if y=='C':
    matrix=input_matrix()
  else:
    matrix,sparse=input_sparse_matrix()
    print("SMS representation:")
    print_sms(sparse)
  matrix=matrix.astype(float).T
  H=input("Enter H for heuristic algorithms or anything else for exact")
  if H=='H':
    print("heuristic Solutions")
    result=algorithm5(matrix)
    print("number of nonzero",nnz(result@matrix))
    print_matrix(np.array([[Fraction(value).limit_denominator() for value in row] for row in result@matrix]).T)
  else:
    r=input("Enter 3 for algorithm2_3 or 4 for algorithm2_4")
    if r=='3':
      result=algorithm2_3(matrix)
    else:
      result=algorithm2_3(matrix)
    print("Exact Solutions")
    print("number of nonzero",nnz(result))
    print_matrix(np.array([[Fraction(value).limit_denominator() for value in row] for row in result]).T)
'''4/9 & -8/9 & -8/9 & -4/9
0 & 5/9 & 0 & 10/9
8/9 & -2/3 & 0 & 0
4/9 & 2/9 & 8/9 & 4/9
0 & -10/9 & 0 & 0
4/9 & -1/3 & -8/9 & 2/3
-4/9 & -2/9 & 8/9 & 4/9
end'''
if __name__ == "__main__":
    main()