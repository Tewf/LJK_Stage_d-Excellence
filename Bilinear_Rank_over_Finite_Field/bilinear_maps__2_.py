# -*- coding: utf-8 -*-
"""bilinear maps

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CrRvKjgvs1lFUEWjvJFOBeBVVqW50wUT
"""

from itertools import combinations
from numpy.linalg import matrix_rank
import numpy as np
from sympy import *
import math
import itertools
import sys

def mod_inv(a, p):
    """ Compute the modular inverse of a under modulo p using the Extended Euclidean Algorithm. """
    t, newt = 0, 1
    r, newr = p, a
    while newr != 0:
        quotient = r // newr
        t, newt = newt, t - quotient * newt
        r, newr = newr, r - quotient * newr
    if r > 1:
        raise ValueError(f"{a} has no inverse modulo {p}")
    if t < 0:
        t += p
    return t

def row_reduce(matrix, p):
    """ Perform row reduction on the matrix under modulo p. """
    matrix = matrix % p
    rows, cols = matrix.shape
    rank = 0

    for col in range(cols):
        if rank >= rows:
            break

        # Find the pivot row
        pivot_row = None
        for row in range(rank, rows):
            if matrix[row, col] != 0:
                pivot_row = row
                break

        if pivot_row is None:
            continue

        # Swap the pivot row with the current rank row
        if pivot_row != rank:
            matrix[[rank, pivot_row]] = matrix[[pivot_row, rank]]

        # Normalize the pivot row
        pivot_value = matrix[rank, col]
        pivot_inv = mod_inv(pivot_value, p)
        matrix[rank] = (matrix[rank] * pivot_inv) % p

        # Eliminate the column entries below the pivot
        for row in range(rank + 1, rows):
            factor = matrix[row, col]
            matrix[row] = (matrix[row] - factor * matrix[rank]) % p

        rank += 1

    # Back substitution to ensure upper triangular form
    for col in range(cols - 1, -1, -1):
        for row in range(rank - 1, -1, -1):
            if matrix[row, col] != 0:
                for elim_row in range(row):
                    factor = matrix[elim_row, col]
                    matrix[elim_row] = (matrix[elim_row] - factor * matrix[row]) % p
                break

    return rank, matrix

def matrix_rank(matrix, p):
    """ Compute the rank of the matrix under modulo p. """
    matrix = np.array(matrix, dtype=int)
    rank, reduced_matrix = row_reduce(matrix, p)
    return rank

def is_linearly_independent(matrices, new_matrix):
  #check if new_matrix is in the span of matrices
    # Handle the case when matrices is empty
    if len(matrices) == 0:
        return not np.all(new_matrix == 0)  # Check if new_matrix is not all zeros

    # Convert the list of matrices to a list of flattened arrays
    flattened_matrices = []
    for m in matrices:
        if isinstance(m, np.ndarray):
            flattened_matrices.append(m.flatten())
        else:
            print(matrices)
            raise ValueError("All elements in 'matrices' must be NumPy arrays")

    # Flatten the new matrix into an array
    flattened_new_matrix = new_matrix.flatten()

    # Combine the flattened matrices into a single matrix
    combined_matrix = np.column_stack(flattened_matrices)

    # Add the flattened new matrix as an additional column
    extended_matrix = np.column_stack((combined_matrix, flattened_new_matrix))

    # Calculate the rank of the original combined matrix
    original_rank = matrix_rank(combined_matrix,p)

    # Calculate the rank of the extended matrix
    extended_rank = matrix_rank(extended_matrix,p)

    # Determine if new_matrix is linearly independent
    if np.all(new_matrix == 0):
        return extended_rank > original_rank  # All-zero new_matrix is only independent if it increases rank
    else:
        return extended_rank == original_rank + 1  # Non-zero new_matrix should increase rank by 1

def Span_it(W,T):
  #check if the base of matrices W can span the matrices in T
  for t in T:
    if(is_linearly_independent(W, t)):
      return False
  return True

def Number_of_multiplications(W):
  # returns the number of multiplications in the tensor W
  s=0
  for j in W:
    s+=matrix_rank(j,p)
  return s

def generate_G(n,m):
  #generate the set of all posiible rank_1 billinear maps
  return my_product(generate_arrays(m),n)

def my_product(list0, n):
  #create all the possible rank_1 matrices where there rows are from list0
  result = [[]]  # Start with an empty list as the base case
  for _ in range(n):
    temp = []
    for combination in result:
      for element in list0:
        if matrix_rank(np.array(combination + [element]),p)<=1:
          #check if the new matrix is of rank_1
          temp.append(combination + [element])  # Append each element to existing combinations
    result = temp  # Update the result with the new combinations
  return independ(result)

def independ(x):
  #given G it will take out all non rank_1 bilinear(rank 0) maps as a final check and takeout the matrices that are a scalar multiple to other matrices example for [1,0] we will take out [2,0]
  s=[]
  for i in x:
    k=True
    for j in s:
      # Reshape the arrays to 2D before comparing
      if(not is_linearly_independent([j], np.array(i))): # Pass as a list of 2D arrays
        k=False
        break
    if(k and not np.all(np.array(i) == 0)):
        s.append(np.array(i))
  return s

def generate_arrays(n):
  #generate all the possible row vectors in Fp with lenght n
    return list(itertools.product([i for i in range(p)], repeat=n))


def auto_verify(x,y):
  #checks if there is an automorphism z such that z.x=y
  #a0,b0=matrix_rank(x,p),np.hstack((x, y))
  a1,b1=matrix_rank(x,p),np.hstack((x.T, y.T))
  return a1==matrix_rank(b1,p)#RP_automorphism

def auto_sort(a,y):
  #returns True if there is an automorphim z such that one of the matrices of y (i) zy=a
  for i in a:
    if(auto_verify(i,y)):
      return True
  return False

def create_of_zeroes(n, m):
  s=[]
  for i in range(n+m-1):
    s.append(np.zeros((n, m), dtype=int))
  return s

def create_Tensor_model_of_polynomial_multiplication(n,m):
  T=create_of_zeroes(n, m)
  for i in range(n+m-1):
    for j in range(n):
      for k in range(m):
        if(k+j==i):
          T[i][j][k]=1
  return T

def substract(x,y,i,n):
  for j in range(len(y)):
    x[i+j]=(x[i+j]-y[j]*n)%p
  return x

'''def polynomial_modular(x,y):
  inverse=mod_inv(y[0], p)
  i=0
  while(i<len(x)-len(y) and x[i]==0):
    i+=1
  while i<=len(x)-len(y):
    x=substract(x,y,i,x[i]*inverse)
    while(i<=len(x)-len(y) and x[i]==0):
      i+=1
  return x'''

def tensor_modular(x,y):
  #does the euclidian division of x by y such that there coefficients are matrices
  inverse=mod_inv(y[0], p)
  i=0
  while(i<=len(x)-len(y) and matrix_rank(x[i],p)==0):
    i+=1
  while i<=len(x)-len(y):
    x=substract(x,y,i,x[i]*inverse)
    while(i<=len(x)-len(y) and matrix_rank(x[i],p)==0):
      i+=1
  return [i for i in x if matrix_rank(i,p)!=0]

def has_one_rank_basis(T, G, p):
    """
    Determines the number of linearly independent matrices in G that are not linearly independent with T.

    Args:
    - T (list of np.ndarray): The target list of matrices.
    - G (list of np.ndarray): The list of matrices to check.
    - p (int): The prime number for modulo operations.

    Returns:
    - int: The number of linearly independent matrices in G that are not linearly independent with T.
    """
    s = []
    for i in G:
        if is_linearly_independent(s, i) and not is_linearly_independent(T, i):
            s.append(i)
    return len(s)

def expand_subspace(W, G, j, k, p):
    """
    Expands the subspace W using matrices from G to achieve a subspace of rank k.

    Args:
    - W (list of np.ndarray): The current subspace.
    - G (list of np.ndarray): The list of matrices to use for expansion.
    - j (int): The starting index in G.
    - k (int): The target rank.
    - p (int): The prime number for modulo operations.

    Returns:
    - list of np.ndarray or None: The expanded subspace if successful, otherwise None.
    """
    HSK = has_one_rank_basis(W, G, p)
    if HSK == k and len(W) == k:
        return W
    if len(W) < k:
        for g in range(j, len(G)):
            if is_linearly_independent(W, G[g], p):
                v = expand_subspace(W + [G[g]], G, g + 1, k, p)
                if v is not None:
                    return v
    return None

def iteration_search(base,T,G):
  #given a tensor T will try to find a base with k multiplication that spans T
  global k
  a,b=Number_of_multiplications(base),Number_of_multiplications(base)+Number_of_multiplications(T)
  for k in range(a,b+1):
    if expand_subspace(base,G,T) is not None:
      return expand_subspace(base,G,T)
  return None

def binary_Search_auto(base, T,G):
  #the binary search version of the iteration search
    global k
    a, b = Number_of_multiplications(base), Number_of_multiplications(base) + Number_of_multiplications(T)
    k = a

    v = None  # Initialize v to ensure it's defined before usage

    # Initial check before binary search loop
    initial_result = auto_expand_subspace(base, G, T)
    if initial_result is not None:
        return initial_result

    # Binary search loop
    while (b - a)//2!= 0:
         # Continue while there is more than one element between a and b
        k = a + (b - a) // 2
        result = auto_expand_subspace(base, G, T)
        if result is not None:
            v = result
            b = k
        else:
            a = k

    # Final check after binary search loop
    if v is not None:
        return v
    else:
        # Check the remaining boundary value
        k = b
        return auto_expand_subspace(base, G, T)

    return None

def binary_Search(base, T,G):
    global k
    a, b = Number_of_multiplications(base), Number_of_multiplications(base) + Number_of_multiplications(T)
    k = a

    v = None  # Initialize v to ensure it's defined before usage

    # Initial check before binary search loop
    initial_result = expand_subspace(base, G, T)
    if initial_result is not None:
        return initial_result

    # Binary search loop
    while (b - a)//2!= 0:
         # Continue while there is more than one element between a and b
        k = a + (b - a) // 2
        result = expand_subspace(base, G, T)
        if result is not None:
            v = result
            b = k
        else:
            a = k

    # Final check after binary search loop
    if v is not None:
        return v
    else:
        # Check the remaining boundary value
        k = b
        return expand_subspace(base, G, T)

    return None

def separater(x):
  #a is all the matrices with the same rank as the first one, b is the rest
  a,b,t=[],[],matrix_rank(x[0], p)
  for i in x:
    if(matrix_rank(i,p)==t):
      a.append(i)
    else:
      b.append(i)
  return a,b

def bottom_up_auto(T):
  base=[]
  n, m = len(T[0]), len(T[0][0])
  G = generate_G(n, m)
  target0,target1=separater(sorted(T, key=lambda x: matrix_rank(x, p)))
  while target1!=[]:
    base=binary_Search_auto(base,target0,G)
    target0,target1=separater(target1)
  return binary_Search_auto(base,target0,G)

def bottom_up(T):
  base=[]
  n, m = len(T[0]), len(T[0][0])
  G = generate_G(n, m)
  target0,target1=separater(sorted(T, key=lambda x: matrix_rank(x, p)))
  while target1!=[]:
    base=binary_Search(base,target0,G)
    target0,target1=separater(target1)
  return binary_Search(base,target0,G)

def multiplier(x,y,p):
  #does a linear combination of the matrices in x such that the scalar multiplied with x[i] is y[i]
    s=x[0]*y[0]
    for i in range(1,len(x)):
        s+=x[i]*y[i]
    return s%p

def span_of(T, p):
    """
    Generates the span of T under modulo p.

    Args:
    - T (list of np.ndarray): The list of matrices.
    - p (int): The prime number for modulo operations.

    Returns:
    - list of np.ndarray: The sorted list of matrices in the span of T.
    """
    G = generate_arrays(len(T))
    s = []
    for i in G:
        s.append(multiplier(i, T, p))
    return sorted(s, key=lambda x: matrix_rank(x, p))

def smallest_base(T, p):
    """
    Finds the smallest base of T under modulo p.

    Args:
    - T (list of np.ndarray): The list of matrices.
    - p (int): The prime number for modulo operations.

    Returns:
    - list of np.ndarray: The smallest base of T.
    """
    G = span_of(T, p)
    s = []
    for i in G:
        if is_linearly_independent(s, i):
            s.append(i)
    return s

def rank_minimizer(T, G, p):
    """
    Minimizes the rank of T using matrices from G under modulo p.

    Args:
    - T (list of np.ndarray): The list of matrices.
    - G (list of np.ndarray): The list of matrices to use for minimization.
    - p (int): The prime number for modulo operations.

    Returns:
    - list of np.ndarray: The minimized rank list of matrices.
    """
    for i in range(len(G)):
        if is_linearly_independent(T, G[i]):
            v = smallest_base(T + [G[i]], p)
            if Number_of_multiplications(v) < Number_of_multiplications(T):
                T = v
            else:
                G_new = [j for j in G[i+1:] if is_linearly_independent(v, j)]
                return rank_minimizer(T, G_new, p)
    return T

def filter(T, G, p, s=None):
    """
    Filters the list of matrices G to find those that minimize the rank of T under modulo p.

    Args:
    - T (list of np.ndarray): The list of matrices.
    - G (list of np.ndarray): The list of matrices to filter.
    - p (int): The prime number for modulo operations.
    - s (list of np.ndarray, optional): The initial list of matrices. Defaults to an empty list.

    Returns:
    - list of np.ndarray: The filtered list of matrices.
    """
    if s is None:
        s = []
    for i in range(len(G)):
        if is_linearly_independent(T + s, G[i]):
            v = smallest_base(T + [G[i]], p)
            if Number_of_multiplications(v) < Number_of_multiplications(T):
                s.append(G[i])
            else:
                G_new = [j for j in G[i+1:] if is_linearly_independent(T + s + v, j)]
                return filter(T, G_new, p, s)
    return s

def Row_Reduce(matrix, p):
    """ Perform row reduction on the matrix under modulo p and return the transformation matrix. """
    matrix = matrix % p
    rows, cols = matrix.shape
    rank = 0

    # Initialize the transformation matrix as the identity matrix
    transformation_matrix = np.eye(rows, dtype=int)

    for col in range(cols):
        if rank >= rows:
            break

        # Find the pivot row
        pivot_row = None
        for row in range(rank, rows):
            if matrix[row, col] != 0:
                pivot_row = row
                break

        if pivot_row is None:
            continue

        # Swap the pivot row with the current rank row
        if pivot_row != rank:
            matrix[[rank, pivot_row]] = matrix[[pivot_row, rank]]
            transformation_matrix[[rank, pivot_row]] = transformation_matrix[[pivot_row, rank]]

        # Normalize the pivot row
        pivot_value = matrix[rank, col]
        pivot_inv = mod_inv(pivot_value, p)
        matrix[rank] = (matrix[rank] * pivot_inv) % p
        transformation_matrix[rank] = (transformation_matrix[rank] * pivot_inv) % p

        # Eliminate the column entries below the pivot
        for row in range(rank + 1, rows):
            factor = matrix[row, col]
            matrix[row] = (matrix[row] - factor * matrix[rank]) % p
            transformation_matrix[row] = (transformation_matrix[row] - factor * transformation_matrix[rank]) % p

        rank += 1

    # Back substitution to ensure upper triangular form
    for col in range(cols - 1, -1, -1):
        for row in range(rank - 1, -1, -1):
            if matrix[row, col] != 0:
                for elim_row in range(row):
                    factor = matrix[elim_row, col]
                    matrix[elim_row] = (matrix[elim_row] - factor * matrix[row]) % p
                    transformation_matrix[elim_row] = (transformation_matrix[elim_row] - factor * transformation_matrix[row]) % p
                break

    return rank, matrix, transformation_matrix

def solve_linear_combination(vectors, target_vector, p):
    """
    Given a list of vectors and a target vector, find the linear combination
    of those vectors such that it equals the target vector over field Fp.
    """
    num_vectors = len(vectors)
    vector_length = len(vectors[0])

    # Convert vectors to a numpy array
    matrix = np.array(vectors).T  # Transpose to make vectors columns
    target_vector = np.array(target_vector).reshape(-1, 1)

    # Form the augmented matrix
    augmented_matrix = np.hstack((matrix, target_vector))

    # Perform row reduction on the augmented matrix
    rank, reduced_matrix, _ = Row_Reduce(augmented_matrix, p)

    # Check if the system is consistent
    if not np.all(reduced_matrix[:, -1][rank:] == 0):
        raise ValueError("No solution exists")

    # Extract the solution from the row-reduced form
    solution = reduced_matrix[:, -1][:rank]
    return solution

def matrix_decomposer(x):
  #given a matrix x returns it's tensor decomposition over Fp
  k,n=0,len(x)
  while all(element == 0 for element in x[k]):
    k+=1
  s=[[x[k],[0]*n]]
  s[0][1][k]=1
  for i in range(k+1,n):
    if matrix_rank([j[0] for j in s]+[x[i]],p)!=matrix_rank([j[0] for j in s],p):
      s.append([x[i],[0]*n])
      s[-1][1][i]=1
    else:
      for t in range(len(s)):
        s[t][1][i]+=(solve_linear_combination([j[0] for j in s],x[i],p))[t]
  return s

def rank1_decomposer(x):
  #given a matrix x returns it's rank_1 matrix decomposition
  return [custom_tensor_product([np.array(i[1])],[np.array(i[0])])[0] for i in matrix_decomposer(x)]

def row_reduce_modified(matrix, p):
    """ Perform row reduction on the matrix under modulo p and return the transformation matrix. """
    matrix = matrix % p
    rows, cols = matrix.shape
    rank = 0

    # Initialize the transformation matrix as the identity matrix
    transformation_matrix = np.eye(rows, dtype=int)

    for col in range(cols):
        if rank >= rows:
            break

        # Find the pivot row
        pivot_row = None
        for row in range(rank, rows):
            if matrix[row, col] != 0:
                pivot_row = row
                break

        if pivot_row is None:
            continue

        # Swap the pivot row with the current rank row
        if pivot_row != rank:
            matrix[[rank, pivot_row]] = matrix[[pivot_row, rank]]
            transformation_matrix[[rank, pivot_row]] = transformation_matrix[[pivot_row, rank]]

        # Normalize the pivot row
        pivot_value = matrix[rank, col]
        pivot_inv = mod_inv(pivot_value, p)
        matrix[rank] = (matrix[rank] * pivot_inv) % p
        transformation_matrix[rank] = (transformation_matrix[rank] * pivot_inv) % p

        # Eliminate the column entries below the pivot
        for row in range(rank + 1, rows):
            factor = matrix[row, col]
            matrix[row] = (matrix[row] - factor * matrix[rank]) % p
            transformation_matrix[row] = (transformation_matrix[row] - factor * transformation_matrix[rank]) % p

        rank += 1

    # Back substitution to ensure upper triangular form
    for col in range(cols - 1, -1, -1):
        for row in range(rank - 1, -1, -1):
            if matrix[row, col] != 0:
                for elim_row in range(row):
                    factor = matrix[elim_row, col]
                    matrix[elim_row] = (matrix[elim_row] - factor * matrix[row]) % p
                    transformation_matrix[elim_row] = (transformation_matrix[elim_row] - factor * transformation_matrix[row]) % p
                break

    return rank, matrix, transformation_matrix

def solve_linear_combinations(matrices, target_matrix):
    """
    Given a list of matrices and a target matrix, find the linear combinations
    of those matrices such that it equals the target matrix under modulo p.
    """
    num_matrices = len(matrices)
    rows, cols = matrices[0].shape
    flat_size = rows * cols

    # Flatten the matrices
    flattened_matrices = [m.flatten() for m in matrices]
    flattened_target = target_matrix.flatten()

    # Form the augmented matrix for the system of linear equations
    augmented_matrix = np.column_stack(flattened_matrices + [flattened_target])

    # Perform row reduction on the augmented matrix
    rank, reduced_matrix, _ = row_reduce_modified(augmented_matrix, p)

    # Extract the solution if it exists
    solution = reduced_matrix[:, -1]
    if np.any(solution > 0):
        return solution
    else:
        raise ValueError("No solution exists")


def solve_tensor_equation(A, B):
  #A=a.B, returns a
  a=[]
  for i in A:
    a+=[solve_linear_combinations(B,i)]
  return np.array(a)[:,:B.shape[0]]

def custom_tensor_product(x,y):
  a=[]
  for i in range(len(x)):
    b=[]
    for j in x[i]:
      b.append((j*y[i])%p)
    a.append(b)
  return np.array(a)

def find_scalar_multiple(A, B, p):
  #returns the scalar k such that Ak=B over Fp
  A_flat = A.flatten()
  B_flat = B.flatten()

  for i in range(len(A_flat)):
    if A_flat[i] != 0:
      k = (B_flat[i] * mod_inv(A_flat[i], p)) % p
      if np.all((A_flat * k) % p == B_flat % p):
        return k
  return None

def first_nonzero_row(matrix):
  for i in range(matrix.shape[0]):
    if np.any(matrix[i] != 0):
      return i
  return None

def reverse_custom_tensor_product(t):
  a,b=[],[]
  for i in t:
    k=first_nonzero_row(i)

    b+=[i[0]]
    a0=[]
    a0+=[0]*k+[1]
    for j in range(k+1,len(i)):
      a0.append(find_scalar_multiple(i[k],i[j],p))
    a.append(a0)
  return np.array(a),np.array(b)

def matrix_tensor_multiplication(a,b):
  #multiply a matrix "a" with a tensor b, ab
  s=[]
  for i in a:
    z=i[0]*b[0]
    for j in range(1,len(b)):
      z+=i[j]*b[j]
    s+=[z]
  return np.array(s)

import sympy as sp
import numpy as np
import ast

def read_matrix_of_matrices():
    print("Enter the matrix of matrices as a nested list (use Python-style input). Type 'end' to finish input:")
    input_str = ""
    while True:
        line = input().strip()
        if line.lower() == 'end':
            break
        input_str += line

    try:
        # Safely parse the input as a nested list structure
        matrix_of_matrices = ast.literal_eval(input_str)
        if not isinstance(matrix_of_matrices, list):
            raise ValueError("Input should be a nested list.")

        # Convert the nested list into an array of NumPy arrays
        result = [np.array(matrix) for matrix in matrix_of_matrices]
        return np.array(result, dtype=object)
    except (SyntaxError, ValueError) as e:
        print("Invalid input format. Please ensure you use a proper nested list format.")
        return None

def read_single_matrix():
    print("Enter the matrix as a nested list (use Python-style input). Type 'end' to finish input:")
    input_str = ""
    while True:
        line = input().strip()
        if line.lower() == 'end':
            break
        input_str += line

    try:
        # Safely parse the input as a nested list structure
        matrix = ast.literal_eval(input_str)
        if not isinstance(matrix, list):
            raise ValueError("Input should be a nested list.")

        # Convert the nested list into a NumPy array
        return np.array(matrix)
    except (SyntaxError, ValueError) as e:
        print("Invalid input format. Please ensure you use a proper nested list format.")
        return None

def is_irreducible(coefficients, p):
    # Define the variable x
    x = symbols('x')

    # Construct the polynomial from the coefficients
    polynomial = sum(coeff * x**i for i, coeff in enumerate(reversed(coefficients)))

    # Define the polynomial ring over the finite field F_p
    Fp = GF(p)
    poly = Poly(polynomial, x, domain=Fp)

    # Factor the polynomial
    factors = factor_list(poly)

    # Check if the polynomial is irreducible over F_p
    # A polynomial is irreducible if it cannot be factored into non-trivial polynomials
    if len(factors[1]) == 1 and factors[1][0][1] == 1:
        return True
    else:
        return False

def read_poly():
    while True:
      coeffs = input(f"Enter the coefficients of the polynomial over Z/{p}Z (e.g., 1 0 3 for 1*x^2 + 0*x + 3): ")
      coeffs = [int(c) % p for c in coeffs.split()]
      # Check if the polynomial is irreducible
      if is_irreducible(coeffs,p):
        return coeffs
      else:
        print("The polynomial is not irreducible over Z/{p}Z. Please try again.")
def rank1_bases(x):
  s=[]
  for i in x:
    s+=rank1_decomposer(i)
  return s

def main():
    global p
    p = int(input("Enter the value for Fp field: "))
    yes=input("Enter Y if you want it modular an irreducible polynomial: ")
    if yes=='Y':
      poly=read_poly()
      bilinear=tensor_modular(create_Tensor_model_of_polynomial_multiplication(len(poly),len(poly))[::-1],poly)
    else:
      tensor_form=input("Enter T if you want to enter the bilinear as a tensor ")
      if tensor_form=='T':
        print("Enter The Bilinear Matrix")
        bilinear=read_matrix_of_matrices()
      else:
        print("Enter The L Matrix")
        L=read_single_matrix()
        print("Enter The R Matrix")
        R=read_single_matrix()
        print("Enter The P Matrix")
        P = read_single_matrix()
        bilinear=(matrix_tensor_multiplication(P,(custom_tensor_product(L,R))))%p
    print("\nOriginal bilinear map:")
    for matrix in bilinear:
        print(matrix)
    T=np.array(bilinear)

    print("\nOriginal Number_of_multiplications")
    print(Number_of_multiplications(T))

    pseudo_solution1 = smallest_base(T, p)
    print("\nEtape 1")
    print(Number_of_multiplications(pseudo_solution1))
    print(pseudo_solution1)

    pseudo_solution2 = rank_minimizer(pseudo_solution1, filter(pseudo_solution1, rank1_bases(pseudo_solution1), p), p)
    print("\nEtape 2")
    print(Number_of_multiplications(pseudo_solution2))
    print(pseudo_solution2)
    L,R=reverse_custom_tensor_product(pseudo_solution2)
    print("L",np.array(L))
    print("R",np.array(R))
    print("P",solve_tensor_equation(bilinear,np.array(pseudo_solution2)))


    print("\nEtape 3")
    print("\nGenerating G")
    n, m = T[0].shape
    G = generate_G(n, m)
    print("\nLength of G", len(G))

    optimized_G = filter(pseudo_solution1, G, p)
    print("\nLength of optimized_G", len(optimized_G))

    pseudo_solution3 = rank_minimizer(pseudo_solution2, filter(pseudo_solution2, optimized_G, p), p)
    print("\nEtape 3")
    print(Number_of_multiplications(pseudo_solution3))
    print(pseudo_solution3)

    L,R=reverse_custom_tensor_product(pseudo_solution3)
    print("L",np.array(L))
    print("R",np.array(R))
    print("P",solve_tensor_equation(bilinear,np.array(pseudo_solution3)))

    print("\nIf you want to know if there is a rank equal to some value k, enter Y")
    input_text = input()
    if input_text == "Y":
        k = int(input("Enter the value of k: "))
        print(f"\nExpanding the subspace to rank {k}")
        expanded_subspace = expand_subspace(pseudo_solution3, G, 1, k, p)
        if expanded_subspace is None:
            print(f"No rank {k} basis found")
        else:
            print(f"Rank {k} basis found:")
            for matrix in expanded_subspace:
                print(matrix)
                print("L,R",reverse_custom_tensor_product(expanded_subspace))
                print("P",solve_tensor_equation(bilinear,np.array(expanded_subspace)))

'''Enter the value for Fp field: 3
Enter Y if you want it modular an irreducible polynomialno
Enter T if you want to enter the bilinear as a tensor T
Enter The Bilinear Matrix
Enter the matrix of matrices as a nested list (use Python-style input). Type 'end' to finish input:
[         [             [ 1, 0, 0, 0, 0 ],             [ 0, 1, 0, 0, 0 ],             [ 0, 0, 1, 0, 0 ],             [ 0, 0, 0, 1, 0 ],             [ 0, 0, 0, 0, 1 ]         ],         [             [ 0, 0, 0, 1, 2 ],             [ 1, 0, 0, 0, 0 ],             [ 0, 1, 0, 0, 0 ],             [ 0, 0, 1, 0, 0 ],             [ 0, 0, 0, 1, 0 ]         ],         [             [ 0, 0, 1, 2, 0 ],             [ 0, 0, 0, 1, 2 ],             [ 1, 0, 0, 0, 0 ],             [ 0, 1, 0, 0, 0 ],             [ 0, 0, 1, 0, 0 ]         ],         [             [ 0, 1, 2, 0, 0 ],             [ 0, 0, 1, 2, 0 ],             [ 0, 0, 0, 1, 2 ],             [ 1, 0, 0, 0, 0 ],             [ 0, 1, 0, 0, 0 ]         ],         [             [ 1, 2, 0, 0, 0 ],             [ 0, 1, 2, 0, 0 ],             [ 0, 0, 1, 2, 0 ],             [ 0, 0, 0, 1, 2 ],             [ 1, 0, 0, 0, 0 ]         ]     ]
end

Original bilinear map:
[[1 0 0 0 0]
 [0 1 0 0 0]
 [0 0 1 0 0]
 [0 0 0 1 0]
 [0 0 0 0 1]]
[[0 0 0 1 2]
 [1 0 0 0 0]
 [0 1 0 0 0]
 [0 0 1 0 0]
 [0 0 0 1 0]]
[[0 0 1 2 0]
 [0 0 0 1 2]
 [1 0 0 0 0]
 [0 1 0 0 0]
 [0 0 1 0 0]]
[[0 1 2 0 0]
 [0 0 1 2 0]
 [0 0 0 1 2]
 [1 0 0 0 0]
 [0 1 0 0 0]]
[[1 2 0 0 0]
 [0 1 2 0 0]
 [0 0 1 2 0]
 [0 0 0 1 2]
 [1 0 0 0 0]]
Enter H for heuristic algorithms or anything else for exact H
Enter F for Field space independent heuristic F

Result :
Minimum number of multiplication 14
L,R (array([[1, 0, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 1, 0],
       [0, 0, 0, 0, 1],
       [1, 0, 0, 2, 0],
       [0, 1, 0, 2, 2],
       [0, 0, 1, 2, 1],
       [1, 0, 0, 2, 1],
       [0, 1, 2, 1, 1],
       [1, 0, 2, 2, 1],
       [0, 1, 1, 1, 2],
       [1, 0, 0, 1, 1],
       [0, 1, 1, 2, 0]]), array([[1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [2, 1, 0, 1, 2],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 2, 1, 1],
       [0, 0, 0, 0, 0],
       [1, 2, 2, 1, 2],
       [0, 0, 0, 0, 0],
       [2, 1, 0, 0, 1],
       [0, 0, 0, 0, 0]], dtype=object))
P [[1 1 1 1 1 0 0 0 0 0 0 0 0 0]
 [0 2 0 1 1 1 0 1 1 2 2 1 1 1]
 [0 2 1 1 1 0 2 2 0 1 2 0 2 2]
 [1 0 2 0 2 2 0 2 0 2 1 1 0 0]
 [0 1 2 0 1 0 2 0 1 2 2 1 1 1]]
 '''
if __name__ == "__main__":
    main()